--- buildroot/package/freerdp/0001-Fix-variable-declaration-in-loop.patch.orig
+++ buildroot/package/freerdp/0001-Fix-variable-declaration-in-loop.patch
@@ -1,37 +0,0 @@
-From 48f25939f4a48b01072f3cd2ece1e36a41c0ad44 Mon Sep 17 00:00:00 2001
-From: Armin Novak <armin.novak@thincast.com>
-Date: Wed, 16 Sep 2020 09:30:37 +0200
-Subject: [PATCH] Fix variable declaration in loop
-
-Upstream: https://github.com/FreeRDP/FreeRDP/commit/ddde652460350b962d32036981ff8ed77ed2f1ed
-Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
-[Dario: make the patch to be applied with fuzz factor 0]
-Signed-off-by: Dario Binacchi <dario.binacchi@amarulasolutions.com>
----
- client/X11/xf_graphics.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
-diff --git a/client/X11/xf_graphics.c b/client/X11/xf_graphics.c
-index 5aa1fd48b5a3..c8f24362aec7 100644
---- a/client/X11/xf_graphics.c
-+++ b/client/X11/xf_graphics.c
-@@ -447,6 +447,7 @@ static void xf_Pointer_Free(rdpContext* context, rdpPointer* pointer)
- 	WLog_DBG(TAG, "%s: %p", __func__, pointer);
- 
- #ifdef WITH_XCURSOR
-+	UINT32 i;
- 	xfContext* xfc = (xfContext*)context;
- 	xfPointer* xpointer = (xfPointer*)pointer;
- 
-@@ -456,7 +457,7 @@ static void xf_Pointer_Free(rdpContext* context, rdpPointer* pointer)
- 	free(xpointer->cursorWidths);
- 	free(xpointer->cursorHeights);
- 
--	for (int i = 0; i < xpointer->nCursors; i++)
-+	for (i = 0; i < xpointer->nCursors; i++)
- 	{
- 		XFreeCursor(xfc->display, xpointer->cursors[i]);
- 	}
--- 
-2.43.0
-
--- buildroot/package/freerdp/0001-MJPEG-input-format-support.patch.orig
+++ buildroot/package/freerdp/0001-MJPEG-input-format-support.patch
@@ -0,0 +1,353 @@
+diff --git a/channels/rdpecam/client/CMakeLists.txt b/channels/rdpecam/client/CMakeLists.txt
+index ce3438ff5..2fa73255f 100644
+--- a/channels/rdpecam/client/CMakeLists.txt
++++ b/channels/rdpecam/client/CMakeLists.txt
+@@ -31,6 +31,16 @@ else()
+ 	message(FATAL_ERROR "libv4l-dev required for CHANNEL_RDPECAM_CLIENT")
+ endif()
+ 
++option(RDPECAM_INPUT_FORMAT_H264 "[MS-RDPECAM] Enable H264 camera format (passthrough)" ON)
++if(RDPECAM_INPUT_FORMAT_H264)
++	add_definitions("-DWITH_INPUT_FORMAT_H264")
++endif()
++
++option(RDPECAM_INPUT_FORMAT_MJPG "[MS-RDPECAM] Enable MJPG camera format" ON)
++if(RDPECAM_INPUT_FORMAT_MJPG)
++	add_definitions("-DWITH_INPUT_FORMAT_MJPG")
++endif()
++
+ include_directories(SYSTEM ${SWSCALE_INCLUDE_DIRS})
+ 
+ set(${MODULE_PREFIX}_SRCS
+diff --git a/channels/rdpecam/client/camera.h b/channels/rdpecam/client/camera.h
+index 76bceb767..85c29b535 100644
+--- a/channels/rdpecam/client/camera.h
++++ b/channels/rdpecam/client/camera.h
+@@ -25,6 +25,10 @@
+ #include <stdlib.h>
+ #include <string.h>
+ 
++#if defined(WITH_INPUT_FORMAT_MJPG)
++#include <libavcodec/avcodec.h>
++#endif
++
+ #include <libswscale/swscale.h>
+ #include <libavutil/imgutils.h>
+ 
+@@ -94,8 +98,15 @@ typedef struct
+ 	wStream* sampleRespBuffer;
+ 
+ 	H264_CONTEXT* h264;
++
++#if defined(WITH_INPUT_FORMAT_MJPG)
++	AVCodecContext* avContext;
++	AVPacket* avInputPkt;
++	AVFrame* avOutFrame;
++#endif
++
++	/* sws_scale */
+ 	struct SwsContext* sws;
+-	int srcLineSizes[4];
+ 
+ } CameraDeviceStream;
+ 
+diff --git a/channels/rdpecam/client/camera_device_main.c b/channels/rdpecam/client/camera_device_main.c
+index e46a220be..407713a23 100644
+--- a/channels/rdpecam/client/camera_device_main.c
++++ b/channels/rdpecam/client/camera_device_main.c
+@@ -24,11 +24,16 @@
+ #define TAG CHANNELS_TAG("rdpecam-device.client")
+ 
+ /* supported formats in preference order:
+- * passthrough, I420 (used as input for H264 encoder), other YUV based, RGB based
++ * H264, MJPG, I420 (used as input for H264 encoder), other YUV based, RGB based
+  */
+ static const CAM_MEDIA_FORMAT_INFO supportedFormats[] = {
+-	/* inputFormat, outputFormat */
+-	{ CAM_MEDIA_FORMAT_H264, CAM_MEDIA_FORMAT_H264 }, /* passthrough: comment out to disable */
++/* inputFormat, outputFormat */
++#if defined(WITH_INPUT_FORMAT_H264)
++	{ CAM_MEDIA_FORMAT_H264, CAM_MEDIA_FORMAT_H264 }, /* passthrough */
++#endif
++#if defined(WITH_INPUT_FORMAT_MJPG)
++	{ CAM_MEDIA_FORMAT_MJPG, CAM_MEDIA_FORMAT_H264 },
++#endif
+ 	{ CAM_MEDIA_FORMAT_I420, CAM_MEDIA_FORMAT_H264 },
+ 	{ CAM_MEDIA_FORMAT_YUY2, CAM_MEDIA_FORMAT_H264 },
+ 	{ CAM_MEDIA_FORMAT_NV12, CAM_MEDIA_FORMAT_H264 },
+diff --git a/channels/rdpecam/client/encoding.c b/channels/rdpecam/client/encoding.c
+index 6712be2e9..ff1bf46b8 100644
+--- a/channels/rdpecam/client/encoding.c
++++ b/channels/rdpecam/client/encoding.c
+@@ -86,6 +86,60 @@ static enum AVPixelFormat ecamToAVPixFormat(CAM_MEDIA_FORMAT ecamFormat)
+ 	}
+ }
+ 
++/**
++ * Function description
++ * initialize libswscale
++ *
++ * @return success/failure
++ */
++static BOOL ecam_init_sws_context(CameraDeviceStream* stream, enum AVPixelFormat pixFormat)
++{
++	WINPR_ASSERT(stream);
++
++	if (stream->sws)
++		return TRUE;
++
++	/* replacing deprecated JPEG formats, still produced by decoder */
++	switch (pixFormat)
++	{
++		case AV_PIX_FMT_YUVJ411P:
++			pixFormat = AV_PIX_FMT_YUV411P;
++			break;
++
++		case AV_PIX_FMT_YUVJ420P:
++			pixFormat = AV_PIX_FMT_YUV420P;
++			break;
++
++		case AV_PIX_FMT_YUVJ422P:
++			pixFormat = AV_PIX_FMT_YUV422P;
++			break;
++
++		case AV_PIX_FMT_YUVJ440P:
++			pixFormat = AV_PIX_FMT_YUV440P;
++			break;
++
++		case AV_PIX_FMT_YUVJ444P:
++			pixFormat = AV_PIX_FMT_YUV444P;
++			break;
++
++		default:
++			break;
++	}
++
++	const int width = (int)stream->currMediaType.Width;
++	const int height = (int)stream->currMediaType.Height;
++
++	stream->sws = sws_getContext(width, height, pixFormat, width, height, AV_PIX_FMT_YUV420P, 0,
++	                             NULL, NULL, NULL);
++	if (!stream->sws)
++	{
++		WLog_ERR(TAG, "sws_getContext failed");
++		return FALSE;
++	}
++
++	return TRUE;
++}
++
+ /**
+  * Function description
+  *
+@@ -96,27 +150,70 @@ static BOOL ecam_encoder_compress_h264(CameraDeviceStream* stream, const BYTE* s
+ {
+ 	UINT32 dstSize = 0;
+ 	BYTE* srcSlice[4] = { 0 };
++	int srcLineSizes[4] = { 0 };
+ 	BYTE* yuv420pData[3] = { 0 };
+ 	UINT32 yuv420pStride[3] = { 0 };
+-	prim_size_t size = { 0 };
+-	size.width = stream->currMediaType.Width;
+-	size.height = stream->currMediaType.Height;
++	prim_size_t size = { stream->currMediaType.Width, stream->currMediaType.Height };
+ 	CAM_MEDIA_FORMAT inputFormat = streamInputFormat(stream);
+-	enum AVPixelFormat pixFormat = ecamToAVPixFormat(inputFormat);
++	enum AVPixelFormat pixFormat = AV_PIX_FMT_NONE;
++
++#if defined(WITH_INPUT_FORMAT_MJPG)
++	if (inputFormat == CAM_MEDIA_FORMAT_MJPG)
++	{
++		stream->avInputPkt->data = (BYTE*)srcData;
++		stream->avInputPkt->size = srcSize;
++
++		if (avcodec_send_packet(stream->avContext, stream->avInputPkt) < 0)
++		{
++			WLog_ERR(TAG, "avcodec_send_packet failed");
++			return FALSE;
++		}
++
++		if (avcodec_receive_frame(stream->avContext, stream->avOutFrame) < 0)
++		{
++			WLog_ERR(TAG, "avcodec_receive_frame failed");
++			return FALSE;
++		}
++
++		for (size_t i = 0; i < 4; i++)
++		{
++			srcSlice[i] = stream->avOutFrame->data[i];
++			srcLineSizes[i] = stream->avOutFrame->linesize[i];
++		}
++
++		/* get pixFormat produced by MJPEG decoder */
++		pixFormat = stream->avContext->pix_fmt;
++	}
++	else
++#endif
++	{
++		pixFormat = ecamToAVPixFormat(inputFormat);
++
++		if (av_image_fill_linesizes(srcLineSizes, pixFormat, (int)size.width) < 0)
++		{
++			WLog_ERR(TAG, "av_image_fill_linesizes failed");
++			return FALSE;
++		}
++
++		if (av_image_fill_pointers(srcSlice, pixFormat, (int)size.height, (BYTE*)srcData,
++		                           srcLineSizes) < 0)
++		{
++			WLog_ERR(TAG, "av_image_fill_pointers failed");
++			return FALSE;
++		}
++	}
+ 
+ 	/* get buffers for YUV420P */
+-	if (h264_get_yuv_buffer(stream->h264, stream->srcLineSizes[0], size.width, size.height,
+-	                        yuv420pData, yuv420pStride) < 0)
++	if (h264_get_yuv_buffer(stream->h264, srcLineSizes[0], size.width, size.height, yuv420pData,
++	                        yuv420pStride) < 0)
+ 		return FALSE;
+ 
+ 	/* convert from source format to YUV420P */
+-	BYTE* ptr = WINPR_CAST_CONST_PTR_AWAY(srcData, BYTE*);
+-	if (av_image_fill_pointers(srcSlice, pixFormat, (int)size.height, ptr, stream->srcLineSizes) <
+-	    0)
++	if (!ecam_init_sws_context(stream, pixFormat))
+ 		return FALSE;
+ 
+ 	const BYTE* cSrcSlice[4] = { srcSlice[0], srcSlice[1], srcSlice[2], srcSlice[3] };
+-	if (sws_scale(stream->sws, cSrcSlice, stream->srcLineSizes, 0, (int)size.height, yuv420pData,
++	if (sws_scale(stream->sws, cSrcSlice, srcLineSizes, 0, (int)size.height, yuv420pData,
+ 	              (int*)yuv420pStride) <= 0)
+ 		return FALSE;
+ 
+@@ -136,12 +233,28 @@ static BOOL ecam_encoder_compress_h264(CameraDeviceStream* stream, const BYTE* s
+ static void ecam_encoder_context_free_h264(CameraDeviceStream* stream)
+ {
+ 	WINPR_ASSERT(stream);
++
+ 	if (stream->sws)
+ 	{
+ 		sws_freeContext(stream->sws);
+ 		stream->sws = NULL;
+ 	}
+ 
++#if defined(WITH_INPUT_FORMAT_MJPG)
++	if (stream->avOutFrame)
++		av_frame_free(&stream->avOutFrame); /* sets to NULL */
++
++	if (stream->avInputPkt)
++	{
++		stream->avInputPkt->data = NULL;
++		stream->avInputPkt->size = 0;
++		av_packet_free(&stream->avInputPkt); /* sets to NULL */
++	}
++
++	if (stream->avContext)
++		avcodec_free_context(&stream->avContext); /* sets to NULL */
++#endif
++
+ 	if (stream->h264)
+ 	{
+ 		h264_context_free(stream->h264);
+@@ -149,6 +262,57 @@ static void ecam_encoder_context_free_h264(CameraDeviceStream* stream)
+ 	}
+ }
+ 
++#if defined(WITH_INPUT_FORMAT_MJPG)
++/**
++ * Function description
++ *
++ * @return success/failure
++ */
++static BOOL ecam_init_mjpeg_decoder(CameraDeviceStream* stream)
++{
++	WINPR_ASSERT(stream);
++
++	const AVCodec* avcodec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);
++	if (!avcodec)
++	{
++		WLog_ERR(TAG, "avcodec_find_decoder failed to find MJPEG codec");
++		return FALSE;
++	}
++
++	stream->avContext = avcodec_alloc_context3(avcodec);
++	if (!stream->avContext)
++	{
++		WLog_ERR(TAG, "avcodec_alloc_context3 failed");
++		return FALSE;
++	}
++
++	stream->avContext->width = stream->currMediaType.Width;
++	stream->avContext->height = stream->currMediaType.Height;
++
++	if (avcodec_open2(stream->avContext, avcodec, NULL) < 0)
++	{
++		WLog_ERR(TAG, "avcodec_open2 failed");
++		return FALSE;
++	}
++
++	stream->avInputPkt = av_packet_alloc();
++	if (!stream->avInputPkt)
++	{
++		WLog_ERR(TAG, "av_packet_alloc failed");
++		return FALSE;
++	}
++
++	stream->avOutFrame = av_frame_alloc();
++	if (!stream->avOutFrame)
++	{
++		WLog_ERR(TAG, "av_frame_alloc failed");
++		return FALSE;
++	}
++
++	return TRUE;
++}
++#endif
++
+ /**
+  * Function description
+  *
+@@ -157,6 +321,7 @@ static void ecam_encoder_context_free_h264(CameraDeviceStream* stream)
+ static BOOL ecam_encoder_context_init_h264(CameraDeviceStream* stream)
+ {
+ 	WINPR_ASSERT(stream);
++
+ 	if (!stream->h264)
+ 		stream->h264 = h264_context_new(TRUE);
+ 
+@@ -190,30 +355,10 @@ static BOOL ecam_encoder_context_init_h264(CameraDeviceStream* stream)
+ 	if (!h264_context_set_option(stream->h264, H264_CONTEXT_OPTION_QP, 0))
+ 		goto fail;
+ 
+-	/* initialize libswscale */
+-	{
+-		const int width = (int)stream->currMediaType.Width;
+-		const int height = (int)stream->currMediaType.Height;
+-		CAM_MEDIA_FORMAT inputFormat = streamInputFormat(stream);
+-		enum AVPixelFormat pixFormat = ecamToAVPixFormat(inputFormat);
+-
+-		if (av_image_fill_linesizes(stream->srcLineSizes, pixFormat, width) < 0)
+-		{
+-			WLog_ERR(TAG, "av_image_fill_linesizes failed");
+-			goto fail;
+-		}
+-
+-		if (!stream->sws)
+-		{
+-			stream->sws = sws_getContext(width, height, pixFormat, width, height,
+-			                             AV_PIX_FMT_YUV420P, 0, NULL, NULL, NULL);
+-		}
+-		if (!stream->sws)
+-		{
+-			WLog_ERR(TAG, "sws_getContext failed");
+-			goto fail;
+-		}
+-	}
++#if defined(WITH_INPUT_FORMAT_MJPG)
++	if (streamInputFormat(stream) == CAM_MEDIA_FORMAT_MJPG && !ecam_init_mjpeg_decoder(stream))
++		goto fail;
++#endif
+ 
+ 	return TRUE;
+ 
--- buildroot/package/freerdp/0002-Fixed-variable-declaration-in-loop.patch.orig
+++ buildroot/package/freerdp/0002-Fixed-variable-declaration-in-loop.patch
@@ -1,38 +0,0 @@
-From b0b856590b523869358875594841f3e6c2919569 Mon Sep 17 00:00:00 2001
-From: akallabeth <akallabeth@posteo.net>
-Date: Tue, 22 Sep 2020 07:43:56 +0200
-Subject: [PATCH] Fixed variable declaration in loop
-
-Upstream: https://github.com/FreeRDP/FreeRDP/commit/4f8a48d96e472e43a5f856c449f61669792ce9fa
-Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
-[Dario: make the patch to be applied with fuzz factor 0]
-Signed-off-by: Dario Binacchi <dario.binacchi@amarulasolutions.com>
----
- client/X11/xf_graphics.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/client/X11/xf_graphics.c b/client/X11/xf_graphics.c
-index c8f24362aec7..c8b604cc6ad4 100644
---- a/client/X11/xf_graphics.c
-+++ b/client/X11/xf_graphics.c
-@@ -246,7 +246,7 @@ static BOOL xf_Pointer_GetCursorForCurrentScale(rdpContext* context, const rdpPo
- 	double xscale;
- 	double yscale;
- 	size_t size;
--	int cursorIndex = -1;
-+	int cursorIndex = -1, i;
- 
- 	if (!context || !pointer || !context->gdi)
- 		return FALSE;
-@@ -264,7 +264,7 @@ static BOOL xf_Pointer_GetCursorForCurrentScale(rdpContext* context, const rdpPo
- 	WLog_DBG(TAG, "%s: scaled: %" PRIu32 "x%" PRIu32 ", desktop: %" PRIu32 "x%" PRIu32, __func__,
- 	         xfc->scaledWidth, xfc->savedHeight, settings->DesktopWidth, settings->DesktopHeight);
- 
--	for (int i = 0; i < xpointer->nCursors; i++)
-+	for (i = 0; i < xpointer->nCursors; i++)
- 	{
- 		if (xpointer->cursorWidths[i] == xTargetSize && xpointer->cursorHeights[i] == yTargetSize)
- 		{
--- 
-2.43.0
-
--- buildroot/package/freerdp/0003-winpr-include-winpr-file.h-fix-build-on-uclibc.patch.orig
+++ buildroot/package/freerdp/0003-winpr-include-winpr-file.h-fix-build-on-uclibc.patch
@@ -1,39 +0,0 @@
-From 21036304f909eae9f7506f48703ba1c74724342b Mon Sep 17 00:00:00 2001
-From: Fabrice Fontaine <fontaine.fabrice@gmail.com>
-Date: Sat, 31 Jul 2021 09:49:27 +0200
-Subject: [PATCH] winpr/include/winpr/file.h: fix build on uclibc
-
-Include stdio.h to fix the following build failure with uclibc raised
-since version 2.4.0 and
-https://github.com/FreeRDP/FreeRDP/commit/eb6777ea69b022c9e43a1576a2192a1cb807b1e6:
-
-In file included from /tmp/instance-0/output-1/build/freerdp-2.4.0/winpr/libwinpr/utils/lodepng/lodepng.c:30:
-/tmp/instance-0/output-1/build/freerdp-2.4.0/winpr/include/winpr/file.h:524:11: error: unknown type name 'FILE'
- WINPR_API FILE* winpr_fopen(const char* path, const char* mode);
-           ^~~~
-
-Fixes:
- - http://autobuild.buildroot.org/results/31e770a330158035e24b7b952bec0030138482b7
-
-Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
-Upstream: https://github.com/FreeRDP/FreeRDP/commit/0976cce458f2281cef6e8c417daf4bbd22bcc087
----
- winpr/include/winpr/file.h | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/winpr/include/winpr/file.h b/winpr/include/winpr/file.h
-index 48a29f9f5..79c9b392c 100644
---- a/winpr/include/winpr/file.h
-+++ b/winpr/include/winpr/file.h
-@@ -30,6 +30,8 @@
- 
- #ifndef _WIN32
- 
-+#include <stdio.h>
-+
- #ifndef MAX_PATH
- #define MAX_PATH 260
- #endif
--- 
-2.30.2
-
--- buildroot/package/freerdp/Config.in.orig
+++ buildroot/package/freerdp/Config.in
@@ -13,6 +13,9 @@
 	select BR2_PACKAGE_LIBOPENSSL_ENABLE_RC4 if BR2_PACKAGE_LIBOPENSSL
 	select BR2_PACKAGE_ZLIB
 	select BR2_PACKAGE_LIBGLIB2
+	select BR2_PACKAGE_ICU
+	select BR2_PACKAGE_FFMPEG_SWSCALE
+	select BR2_PACKAGE_LIBV4L
 	help
 	  FreeRDP is a free implementation of the Remote Desktop
 	  Protocol (RDP), released under the Apache license
--- buildroot/package/freerdp/freerdp.hash.orig
+++ buildroot/package/freerdp/freerdp.hash
@@ -1,5 +1,6 @@
 # From https://pub.freerdp.com/releases/freerdp-2.11.7.tar.gz.sha256
 sha256  5a2d54e1ca0f1facd1632bcc94c73b9f071a80c5fdbbb3f26e79f02aaa586ca3  freerdp-2.11.7.tar.gz
+sha256  f7233629ed5990429b60e453f076a9b7bf4d964e92b3e5495a7bdb6e3830dfef  freerdp-b8912282796a0aeb398d7cfdcdf0c595af496f0c.tar.gz
 
 # Locally calculated
 sha256  cfc7749b96f63bd31c3c42b5c471bf756814053e847c10f3eb003417bc523d30  LICENSE
--- buildroot/package/freerdp/freerdp.mk.orig
+++ buildroot/package/freerdp/freerdp.mk
@@ -4,16 +4,18 @@
 #
 ################################################################################
 
-FREERDP_VERSION = 2.11.7
-FREERDP_SITE = https://pub.freerdp.com/releases
-FREERDP_DEPENDENCIES = libglib2 openssl zlib
+FREERDP_VERSION = b8912282796a0aeb398d7cfdcdf0c595af496f0c
+FREERDP_SITE = $(call github,FreeRDP,FreeRDP,$(FREERDP_VERSION))
+#FREERDP_SITE = https://pub.freerdp.com/releases
+FREERDP_DEPENDENCIES = libglib2 openssl zlib icu libv4l host-pkgconf
 FREERDP_LICENSE = Apache-2.0
 FREERDP_LICENSE_FILES = LICENSE
 FREERDP_CPE_ID_VENDOR = freerdp
+FREERDP_CMAKE_BACKEND = ninja
 
 FREERDP_INSTALL_STAGING = YES
 
-FREERDP_CONF_OPTS = -DWITH_MANPAGES=OFF -Wno-dev -DWITH_GSTREAMER_0_10=OFF
+FREERDP_CONF_OPTS = -DWITH_MANPAGES=OFF -Wno-dev -DWITH_GSTREAMER_0_10=OFF -DCHANNEL_RDPECAM_CLIENT=ON -DALLOW_IN_SOURCE_BUILD=ON -DPKG_CONFIG_EXECUTABLE=$(HOST_DIR)/bin/pkg-config -DWITH_CLIENT_SDL=OFF
 
 ifeq ($(BR2_PACKAGE_FREERDP_GSTREAMER1),y)
 FREERDP_CONF_OPTS += -DWITH_GSTREAMER_1_0=ON
@@ -261,12 +263,12 @@
 # can be built and linked with libfreerdp (e.g. weston with the  RDP
 # backend). Key and cert are installed world-readable, so non-root users
 # can start a server.
-define FREERDP_INSTALL_KEYS
-	$(INSTALL) -m 0644 -D $(@D)/server/Sample/server.key \
-		$(TARGET_DIR)/etc/freerdp/keys/server.key
-	$(INSTALL) -m 0644 -D $(@D)/server/Sample/server.crt \
-		$(TARGET_DIR)/etc/freerdp/keys/server.crt
-endef
-FREERDP_POST_INSTALL_TARGET_HOOKS += FREERDP_INSTALL_KEYS
+#define FREERDP_INSTALL_KEYS
+#	$(INSTALL) -m 0644 -D $(@D)/server/Sample/server.key \
+#		$(TARGET_DIR)/etc/freerdp/keys/server.key
+#	$(INSTALL) -m 0644 -D $(@D)/server/Sample/server.crt \
+#		$(TARGET_DIR)/etc/freerdp/keys/server.crt
+#endef
+#FREERDP_POST_INSTALL_TARGET_HOOKS += FREERDP_INSTALL_KEYS
 
 $(eval $(cmake-package))
